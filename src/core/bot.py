"""
Chatbot Educacional para Engenharia de Software - UFC Quixad√°

Este m√≥dulo implementa o n√∫cleo do chatbot desenvolvido como parte do TCC,
fornecendo interface conversacional via Telegram para consultas acad√™micas.

Funcionalidades principais:
- Interface com API do Telegram
- Sistema de menus hier√°rquicos para navega√ß√£o
- Processamento inteligente de perguntas em linguagem natural
- Integra√ß√£o com base de conhecimento do PPC-ES 2023
- Analytics e armazenamento de dados de uso

Arquitetura:
- Message Router: Roteia mensagens entre handlers apropriados
- Question Processor: Processa perguntas usando m√∫ltiplas estrat√©gias
- Menu System: Sistema hier√°rquico de navega√ß√£o por t√≥picos
- Media Handlers: Tratamento de diferentes tipos de m√≠dia

Autor: Desenvolvimento para TCC - Engenharia de Software UFC Quixad√°
Data: 2025
"""

import json
import os
from difflib import SequenceMatcher
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters,
)
from dotenv import load_dotenv

from src.services.storage.vercel_storage import vercel_storage
from src.services.ai.flan_service import flan_service, DEFAULT_CONTEXT
from src.services.search.ppc_search import ppc_search

load_dotenv()

TOKEN = os.getenv("TELEGRAM_TOKEN")

async def send_long_message(update: Update, message: str, parse_mode: str = 'Markdown'):
    """Envia mensagem longa dividindo em chunks se necess√°rio"""
    MAX_MESSAGE_LENGTH = 4000  # Deixa margem de seguran√ßa
    
    if len(message) <= MAX_MESSAGE_LENGTH:
        await update.message.reply_text(message, parse_mode=parse_mode)
        return
    
    # Divide a mensagem em chunks
    chunks = []
    current_chunk = ""
    
    for line in message.split('\n'):
        if len(current_chunk) + len(line) + 1 <= MAX_MESSAGE_LENGTH:
            current_chunk += line + '\n'
        else:
            if current_chunk:
                chunks.append(current_chunk.strip())
            current_chunk = line + '\n'
    
    if current_chunk:
        chunks.append(current_chunk.strip())
    
    # Envia cada chunk
    for i, chunk in enumerate(chunks):
        if i == 0:
            await update.message.reply_text(chunk, parse_mode=parse_mode)
        else:
            await update.message.reply_text(f"(continua√ß√£o...)\n\n{chunk}", parse_mode=parse_mode)

# Carrega perguntas e respostas
with open("data/qa/perguntas_respostas_melhorado.json", encoding="utf-8") as f:
    DATA = json.load(f)
    QA = DATA["qa_items"]
    AMBIGUITY_CONFIG = DATA["ambiguity_detection"]

# Menus
MAIN_MENU = [
    ["üìö Informa√ß√µes sobre Est√°gio"],
    ["üéì Informa√ß√µes sobre Matr√≠cula"],    
    ["üìù Registrar Dados Acad√™micos"],
    ["üìû Fale com a Coordena√ß√£o"],
    ["üèÜ Atividades Complementares"],
]

ESTAGIO_MENU = [
    ["üíº Est√°gio Curricular Supervisionado"],
    ["üè¢ Empresas Conveniadas para Est√°gio"],
    ["üèõÔ∏è N√∫cleo de Pr√°ticas em Inform√°tica (NPI)"],
    ["üöÄ Iniciativa Empreendedora (IE)"],
    ["üî¨ Projetos de Pesquisa como Est√°gio"],
    ["üîô Voltar ao Menu Principal"]
]

MATRICULA_MENU = [
    ["üìÖ Calend√°rio Acad√™mico"],
    ["üìù Como se Matricular"],
    ["üîÑ Trancamento/Cancelamento"],
    ["üìä Hist√≥rico Escolar"],
    ["üîô Voltar ao Menu Principal"]
]

CURSO_MENU = [
    ["üìù Trabalho de Conclus√£o de Curso (TCC)"],
    ["üåç Curriculariza√ß√£o da Extens√£o"],
    ["üìñ Metodologias de Ensino"],
    ["‚öñÔ∏è Avalia√ß√£o do Curso"],
    ["üë• Gest√£o Acad√™mica"],
    ["üîô Voltar ao Menu Principal"]
]

# Fun√ß√£o de similaridade melhorada
def similarity(a: str, b: str) -> float:
    return SequenceMatcher(None, a.lower(), b.lower()).ratio()

def advanced_similarity(query: str, item: dict) -> float:
    """
    Calcula similaridade avan√ßada considerando m√∫ltiplos fatores.
    
    Algoritmo multi-fator que combina diferentes m√©tricas de similaridade
    para melhorar a precis√£o do matching entre perguntas do usu√°rio e
    itens da base de conhecimento.
    
    Args:
        query (str): Pergunta do usu√°rio
        item (dict): Item da base Q&A com estrutura:
                    - pergunta: pergunta principal
                    - variacoes: lista de varia√ß√µes da pergunta
                    - tags: lista de palavras-chave
    
    Returns:
        float: Score de similaridade entre 0.0 e 1.0
        
    Fatores considerados:
        - Similaridade textual com pergunta principal (60%)
        - Similaridade com varia√ß√µes
        - Matching de tags (20%)
        - Matching de palavras-chave espec√≠ficas (20%)
    """
    query_lower = query.lower()
    
    # Similaridade com a pergunta principal
    main_score = similarity(query, item["pergunta"])
    
    # Similaridade com varia√ß√µes
    variation_scores = []
    for variacao in item.get("variacoes", []):
        variation_scores.append(similarity(query, variacao))
    
    max_variation_score = max(variation_scores) if variation_scores else 0
    
    # Similaridade com tags
    tag_score = 0
    for tag in item.get("tags", []):
        if tag.lower() in query_lower:
            tag_score += 0.3
    
    # Pontua√ß√£o por palavras-chave espec√≠ficas
    keyword_score = 0
    query_words = query_lower.split()
    for word in query_words:
        if len(word) > 3:  # Ignora palavras muito pequenas
            for variacao in item.get("variacoes", []):
                if word in variacao.lower():
                    keyword_score += 0.2
    
    # Combina as pontua√ß√µes
    final_score = max(main_score, max_variation_score) * 0.6 + tag_score * 0.2 + keyword_score * 0.2
    
    return min(final_score, 1.0)  # Limita a 1.0

# üèÅ Start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    vercel_storage.store_analytics("bot_start", {
        "user_id": update.effective_user.id,
        "username": update.effective_user.username,
        "first_name": update.effective_user.first_name
    })

    await update.message.reply_text(
        f"üéì Ol√° {update.effective_user.first_name}! Bem-vindo ao ChatBot da Coordena√ß√£o de Engenharia de Software.\n\n"
        "Escolha uma op√ß√£o abaixo ou digite sua pergunta.",
        reply_markup=ReplyKeyboardMarkup(MAIN_MENU, resize_keyboard=True)
    )
    context.user_data["step"] = "main_menu"

# üéØ Menu Principal
async def handle_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message.text

    if msg == "üìö Informa√ß√µes sobre Est√°gio":
        await update.message.reply_text(
            "Selecione uma op√ß√£o:",
            reply_markup=ReplyKeyboardMarkup(ESTAGIO_MENU, resize_keyboard=True)
        )
        context.user_data["step"] = "estagio_menu"

    elif msg == "üéì Informa√ß√µes sobre Matr√≠cula":
        await update.message.reply_text(
            "Selecione uma op√ß√£o:",
            reply_markup=ReplyKeyboardMarkup(MATRICULA_MENU, resize_keyboard=True)
        )
        context.user_data["step"] = "matricula_menu"

    elif msg == "üìù Registrar Dados Acad√™micos":
        context.user_data["step"] = "cadastro_nome"
        await update.message.reply_text("Informe seu nome completo:", reply_markup=ReplyKeyboardRemove())

    elif msg == "üìû Fale com a Coordena√ß√£o":
        await handle_specific_question(update, context, "üìû Fale com a Coordena√ß√£o")

    elif msg == "üèÜ Atividades Complementares":
        await handle_specific_question(update, context, "üèÜ Atividades Complementares")

    elif msg == "üîô Voltar ao Menu Principal":
        await start(update, context)

    else:
        await handle_free_question(update, context)

# üìù Cadastro guiado
async def handle_cadastro(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_data = vercel_storage.get_user_data(user.id) or {}

    text = (
        "üìù **Seus Dados Acad√™micos**\n\n"
        f"üë§ Nome: {user_data.get('nome', 'N√£o informado')}\n"
        f"üéì Matr√≠cula: {user_data.get('matricula', 'N√£o informado')}\n"
        f"üìÖ Semestre: {user_data.get('semestre', 'N√£o informado')}\n"
        f"üìß Email: {user_data.get('email', 'N√£o informado')}\n\n"
        "Para atualizar, use os comandos:\n"
        "/nome Seu Nome\n"
        "/matricula 123456\n"
        "/semestre de inicio2024.1\n"
        "/email seu@email.com"
    )

    await update.message.reply_text(text, parse_mode="Markdown")

# üéØ Pergunta espec√≠fica do menu
async def handle_specific_question(update: Update, context: ContextTypes.DEFAULT_TYPE, question: str):
    """Handle questions triggered by menu options"""
    # Procura pela pergunta espec√≠fica no JSON
    for item in QA:
        if item["pergunta"] == question:
            await update.message.reply_text(item["resposta"], parse_mode='Markdown')
            return
    
    # Fallback para busca livre se n√£o encontrar
    await handle_free_question(update, context)

# üîç Detec√ß√£o de perguntas amb√≠guas
def is_ambiguous_question(question: str) -> bool:
    """Detecta se uma pergunta √© muito amb√≠gua ou gen√©rica"""
    question_lower = question.lower()
    
    # Carrega configura√ß√µes do JSON
    ambiguous_keywords = AMBIGUITY_CONFIG["keywords"]
    generic_terms = AMBIGUITY_CONFIG["generic_terms"]
    
    # Conta palavras amb√≠guas
    ambiguous_count = sum(1 for keyword in ambiguous_keywords if keyword in question_lower)
    
    # Verifica se tem termos gen√©ricos sem especifica√ß√£o
    has_generic = any(term in question_lower for term in generic_terms)
    
    # Pergunta muito curta (menos de 20 caracteres)
    is_too_short = len(question.strip()) < 20
    
    # Considera amb√≠gua se tem muitas palavras amb√≠guas OU √© muito gen√©rica
    return (ambiguous_count >= 2) or (has_generic and ambiguous_count >= 1) or is_too_short

# üí¨ Gerar pedidos de esclarecimento
def generate_clarification_request(question: str) -> str:
    """Gera um pedido de esclarecimento espec√≠fico baseado na pergunta"""
    question_lower = question.lower()
    
    # Carrega mapeamento do JSON
    clarification_map = AMBIGUITY_CONFIG["clarification_map"]
    
    # Encontra o termo mais relevante
    relevant_clarifications = []
    for term, clarifications in clarification_map.items():
        if term in question_lower:
            relevant_clarifications.extend(clarifications)
    
    # Se n√£o encontrou termos espec√≠ficos, usa esclarecimento gen√©rico
    if not relevant_clarifications:
        relevant_clarifications = AMBIGUITY_CONFIG["default_clarifications"]
    
    clarification_text = "\n".join(relevant_clarifications[:5])  # Limita a 5 op√ß√µes
    
    return (
        f"ü§î Sua pergunta precisa de mais detalhes para eu te ajudar melhor.\n\n"
        f"**Voc√™ est√° perguntando sobre:**\n"
        f"{clarification_text}\n\n"
        f"üí° **Dica:** Seja mais espec√≠fico em sua pergunta para obter uma resposta mais precisa.\n"
        f"üìû **Ou contate:** es@quixada.ufc.br"
    )

# ‚ùì Perguntas livres
async def handle_free_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    question = update.message.text
    
    # 0. Verifica se a pergunta √© muito amb√≠gua
    if is_ambiguous_question(question):
        clarification = generate_clarification_request(question)
        await update.message.reply_text(clarification, parse_mode='Markdown')
        return
    
    # 1. Busca avan√ßada no JSON local
    scored_items = []
    for item in QA:
        score = advanced_similarity(question, item)
        if score > 0.3:  # Threshold mais baixo para capturar mais op√ß√µes
            scored_items.append((item, score))
    
    # Ordena por score e pega o melhor
    if scored_items:
        scored_items.sort(key=lambda x: x[1], reverse=True)
        best_match, best_score = scored_items[0]
        
        if best_score >= 0.5:  # Threshold ajustado
            response = best_match["resposta"]
            await update.message.reply_text(response, parse_mode='Markdown')
            return

    # 2. Busca por tags (mantida como fallback)
    for qa_item in QA:
        if any(tag.lower() in question.lower() for tag in qa_item.get("tags", [])):
            response = qa_item["resposta"]
            await update.message.reply_text(response, parse_mode='Markdown')
            return

    # 3. Busca no PPC
    ppc_response = ppc_search.get_formatted_response(question)
    if ppc_response:
        await send_long_message(update, ppc_response)
        return

    # 4. Verifica√ß√£o final antes do fallback
    if len(question.strip()) < 10:
        await update.message.reply_text(
            "ü§î Sua pergunta est√° muito curta.\n\n"
            "üí° **Tente ser mais espec√≠fico:**\n"
            "‚Ä¢ Qual √© exatamente sua d√∫vida?\n"
            "‚Ä¢ Sobre qual assunto voc√™ precisa de ajuda?\n\n"
            "üìû **Ou contate:** es@quixada.ufc.br",
            parse_mode='Markdown'
        )
        return

    # 5. Fallback controlado (apenas para perguntas bem estruturadas)
    try:
        # Contexto din√¢mico baseado no PPC
        ppc_context = ppc_search.get_context_for_flan(question)
        
        # S√≥ usa FLAN se encontrou contexto relevante no PPC
        if ppc_context and len(ppc_context.strip()) > 50:
            context_text = f"{DEFAULT_CONTEXT}\n\nContexto do PPC:\n{ppc_context}"
            resposta = flan_service.generate_response(question, context_text)
            await send_long_message(update, resposta)
        else:
            # Sem contexto suficiente, n√£o tenta responder
            await update.message.reply_text(
                "üòî N√£o encontrei informa√ß√µes espec√≠ficas sobre sua pergunta.\n\n"
                "üí° **Sugest√µes:**\n"
                "‚Ä¢ Tente reformular com palavras-chave mais espec√≠ficas\n"
                "‚Ä¢ Use o menu principal para navegar por t√≥picos\n"
                "‚Ä¢ Consulte: https://es.quixada.ufc.br\n"
                "‚Ä¢ Fale com a coordena√ß√£o: es@quixada.ufc.br",
                parse_mode='Markdown'
            )
    except Exception as e:
        print(f"Erro FLAN-T5: {e}")
        await update.message.reply_text(
            "üòî N√£o consegui processar sua pergunta no momento.\n\n"
            "üí° **Sugest√µes:**\n"
            "‚Ä¢ Tente reformular sua pergunta\n"
            "‚Ä¢ Use o menu principal para navegar\n"
            "‚Ä¢ Consulte: https://es.quixada.ufc.br\n"
            "‚Ä¢ Fale com a coordena√ß√£o: es@quixada.ufc.br",
            parse_mode='Markdown'
        )

# üéµ Handler para √°udio
async def handle_audio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Responde quando usu√°rio envia √°udio"""
    await update.message.reply_text(
        "üéµ **√Åudio recebido!**\n\n"
        "Ainda n√£o consigo processar mensagens de √°udio, mas estou aprendendo! ü§ñ\n\n"
        "üí° **Por enquanto, voc√™ pode:**\n"
        "‚Ä¢ Escrever sua pergunta em texto\n"
        "‚Ä¢ Descrever o que voc√™ gostaria de saber\n"
        "‚Ä¢ Usar o menu principal para navegar\n\n"
        "üìû **Urgente?** Contate: es@quixada.ufc.br",
        parse_mode='Markdown'
    )

# üì∑ Handler para imagens
async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Responde quando usu√°rio envia imagem"""
    await update.message.reply_text(
        "üì∑ **Imagem recebida!**\n\n"
        "Ainda n√£o consigo analisar imagens, mas estou evoluindo! ü§ñ\n\n"
        "üí° **Por enquanto, voc√™ pode:**\n"
        "‚Ä¢ Descrever o conte√∫do da imagem em texto\n"
        "‚Ä¢ Fazer sua pergunta por escrito\n"
        "‚Ä¢ Usar o menu principal para navegar\n\n"
        "üìû **Precisa de ajuda?** Contate: es@quixada.ufc.br",
        parse_mode='Markdown'
    )

# üìπ Handler para v√≠deos
async def handle_video(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Responde quando usu√°rio envia v√≠deo"""
    await update.message.reply_text(
        "üìπ **V√≠deo recebido!**\n\n"
        "Ainda n√£o consigo processar v√≠deos, mas estou me desenvolvendo! ü§ñ\n\n"
        "üí° **Por enquanto, voc√™ pode:**\n"
        "‚Ä¢ Descrever o conte√∫do do v√≠deo em texto\n"
        "‚Ä¢ Fazer sua pergunta por escrito\n"
        "‚Ä¢ Usar o menu principal para informa√ß√µes\n\n"
        "üìû **Precisa de ajuda?** Contate: es@quixada.ufc.br",
        parse_mode='Markdown'
    )

# üìÑ Handler para documentos
async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Responde quando usu√°rio envia documento"""
    file_name = update.message.document.file_name if update.message.document.file_name else "documento"
    
    await update.message.reply_text(
        f"üìÑ **Documento '{file_name}' recebido!**\n\n"
        "Ainda n√£o consigo analisar documentos, mas estou aprendendo! ü§ñ\n\n"
        "üí° **Por enquanto, voc√™ pode:**\n"
        "‚Ä¢ Copiar e colar o texto do documento\n"
        "‚Ä¢ Resumir o conte√∫do em sua pergunta\n"
        "‚Ä¢ Usar o menu principal para navegar\n\n"
        "üìû **Documento oficial?** Envie para: es@quixada.ufc.br",
        parse_mode='Markdown'
    )

# üé§ Handler para notas de voz
async def handle_voice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Responde quando usu√°rio envia nota de voz"""
    await update.message.reply_text(
        "üé§ **Nota de voz recebida!**\n\n"
        "Ainda n√£o consigo ouvir notas de voz, mas estou me aperfei√ßoando! ü§ñ\n\n"
        "üí° **Por enquanto, voc√™ pode:**\n"
        "‚Ä¢ Escrever sua pergunta em texto\n"
        "‚Ä¢ Usar palavras-chave espec√≠ficas\n"
        "‚Ä¢ Navegar pelo menu principal\n\n"
        "üìû **Urgente?** Contate: es@quixada.ufc.br",
        parse_mode='Markdown'
    )

# üìç Handler para localiza√ß√£o
async def handle_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Responde quando usu√°rio envia localiza√ß√£o"""
    await update.message.reply_text(
        "üìç **Localiza√ß√£o recebida!**\n\n"
        "Obrigado por compartilhar! Ainda n√£o processo localiza√ß√µes, mas estou evoluindo! ü§ñ\n\n"
        "üè´ **Campus UFC Quixad√°:**\n"
        "‚Ä¢ Endere√ßo: Av. Jos√© de Freitas Queiroz, 5003\n"
        "‚Ä¢ Bairro: Cedro, Quixad√° - CE\n"
        "‚Ä¢ CEP: 63902-580\n\n"
        "üí° **Precisa de informa√ß√µes?** Use o menu principal ou escreva sua pergunta.",
        parse_mode='Markdown'
    )

# üéÆ Handler para outros tipos de m√≠dia
async def handle_other_media(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler gen√©rico para outros tipos de m√≠dia"""
    media_type = "m√≠dia"
    
    if update.message.sticker:
        media_type = "sticker"
    elif update.message.animation:
        media_type = "GIF"
    elif update.message.video_note:
        media_type = "v√≠deo circular"
    
    await update.message.reply_text(
        f"üì± **{media_type.title()} recebido!**\n\n"
        "Ainda n√£o consigo processar esse tipo de conte√∫do, mas estou aprendendo! ü§ñ\n\n"
        "üí° **Por enquanto, voc√™ pode:**\n"
        "‚Ä¢ Escrever sua pergunta em texto\n"
        "‚Ä¢ Usar o menu principal para navegar\n"
        "‚Ä¢ Ser espec√≠fico em suas d√∫vidas\n\n"
        "üìû **Precisa de ajuda?** Contate: es@quixada.ufc.br",
        parse_mode='Markdown'
    )

# üöÄ Main
def main():
    print("Bot iniciado...")
    app = Application.builder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    
    # üì± Handlers para diferentes tipos de m√≠dia
    app.add_handler(MessageHandler(filters.AUDIO, handle_audio))
    app.add_handler(MessageHandler(filters.PHOTO, handle_photo))
    app.add_handler(MessageHandler(filters.VIDEO, handle_video))
    app.add_handler(MessageHandler(filters.Document.ALL, handle_document))
    app.add_handler(MessageHandler(filters.VOICE, handle_voice))
    app.add_handler(MessageHandler(filters.LOCATION, handle_location))
    app.add_handler(MessageHandler(filters.Sticker.ALL | filters.ANIMATION | filters.VIDEO_NOTE, handle_other_media))
    
    # üí¨ Handler para mensagens de texto (deve vir por √∫ltimo)
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, route_message))

    print("Bot rodando!")
    app.run_polling(allowed_updates=Update.ALL_TYPES)

# üîÄ Roteador
async def route_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    step = context.user_data.get("step", "main_menu")
    msg = update.message.text
    
    # Handle submenu navigation
    if step == "estagio_menu":
        await handle_estagio_menu(update, context)
    elif step == "matricula_menu":
        await handle_matricula_menu(update, context)
    elif step == "curso_menu":
        await handle_curso_menu(update, context)
    elif step.startswith("cadastro"):
        await handle_cadastro(update, context)
    else:
        await handle_menu(update, context)

# üìö Menu Est√°gio
async def handle_estagio_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message.text
    
    if msg == "üîô Voltar ao Menu Principal":
        await start(update, context)
    else:
        await handle_specific_question(update, context, msg)

# üéì Menu Matr√≠cula
async def handle_matricula_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message.text
    
    if msg == "üîô Voltar ao Menu Principal":
        await start(update, context)
    else:
        await handle_specific_question(update, context, msg)

# üìñ Menu Curso
async def handle_curso_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message.text
    
    if msg == "üîô Voltar ao Menu Principal":
        await start(update, context)
    else:
        await handle_specific_question(update, context, msg)

if __name__ == "__main__":
    main()
